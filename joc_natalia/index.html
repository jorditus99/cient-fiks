<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>El laberint de clavegueres</title>
    <link rel="stylesheet" href="../joc_natalia/style.css">
</head>
<body>
    <div id="background">
        <!-- <img class="imatge_joc" src="/img/img_natalia/grass_bg.png" > -->

        <div class="table-container" id="table-container">
            <div id="score">Manivelas: 0/4</div>
            <div id="life" class="life"></div>
            <table>
                <!-- here is where the map generates -->
            </table>
        </div>

        <button id = 'one' type="button" name="Click to Play" onClick = 'initializeGame();'>Jugar!</button>
    </div>

    <script>
        // Maze definition
        let maze = [
            `#_#######################################`,
            `#.#.....?..#........#.....#.......#.....#`,
            `#.####....?####.#####.###.###.#.#######.#`,
            `#?....?###....#.........#.....#.#.......#`,
            `###.####.###.##.#########.###.###.#######`,
            `#...#.....#.....#.......#.#.............#`,
            `#.###.###.#.###########.###########.#####`,
            `#...#.#.#.#.#..#...#..........#.........#`,
            `###.#.#.#......#.....#.########.#######.#`,
            `#...#.#.########...#.#........#.......#.#`,
            `#.#.#...#......#####.######.#.#.#####...#`,
            `#.#.###.#####...#.........#.#...#.#.#...#`,
            `#.#...#.....#.#.#.#######.#.#####.#.....#`,
            `#.#########.#.#.#.......#.#.......#.##.##`,
            `#........#....#.####.######.#####...#...#`,
            `#####.###########.........#.#...#####.###`,
            `#.#...#...........###########.#.#.......#`,
            `#.###.#.######.##.#.....#.#...###.#######`,
            `#...#.#.#....#.#..#.#####.#.#.#.#.#.....#`,
            `###.###.#.####.#.##.#...#.#.#.#.#.#.###.#`,
            `#.......#......#.#..#.#.#...#.........#.#`,
            `#.#...#####.####.#.##.#.###.####.######.#`,
            `#.#..........#........#........#.#......#`,
            `################################!########`
        ];

        // GLOBAL VARIABLES
        let currentLevel = maze;
        let tableDiv = document.getElementById('background');
        let table = document.querySelector('table');
        const scoreDisplay = document.getElementById('score');
        const lifeContainer = document.getElementById('life');
        const tableContainer = document.getElementById('table-container');
        
        // Key states and counters
        let isOnKeyTile = false;
        let keyTile = null;
        let originalColor = 'rgb(255, 158, 247)';
        let keyStates = new Map();
        let activatedKeyTiles = 0;
        let score = 0;
        let life = 3;
        let gameInterval;
        let vides = [];

        function initializeGame() {
            imprimir_vides();
            loadPage();
        }

        // DRAWING OF MAZE
        function loadPage() {


            let mover = document.createElement('div');
            mover.style.left = '18%';
            mover.style.top = '15%';
            mover.setAttribute('id', 'player');
            mover.textContent = '@';
            tableDiv.appendChild(mover);

            // Function to create an enemy
            function createEnemy(left, top) {
                const enemy = document.createElement('div');
                enemy.classList.add('enemy');
                enemy.style.left = `${left}%`;
                enemy.style.top = `${top}%`;
                tableDiv.appendChild(enemy);
                return enemy;
            }

            // Initialize multiple enemies
            let enemies = [
                { element: createEnemy(48, 37), direction: -1 },
                { element: createEnemy(28, 66), direction: -1 },
                { element: createEnemy(63, 79), direction: -1 }
            ];

            // Draw the maze
            for (let i = 0; i < currentLevel.length; i++) {
                let row = document.createElement('tr');
                table.appendChild(row);
                for (let x = 0; x < currentLevel[i].length; x++) {
                    let cell = document.createElement('td');
                    row.appendChild(cell);
                    cell.innerHTML = maze[i].charAt(x);
                    switch (maze[i].charAt(x)) {
                        case '#': cell.classList.add('wall'); break;
                        case '.': cell.classList.add('freespace'); break;
                        case '_': cell.id = 'start'; break;
                        case '!': cell.id = 'win'; break;
                        case '?': 
                            cell.classList.add('key'); 
                            keyStates.set(cell, false); 
                            break;
                    }
                }
            }

            // Enemy movement function
            function moveEnemy(enemyObj) {
                const enemy = enemyObj.element;
                let enemyPosition = parseFloat(window.getComputedStyle(enemy).left);
                let direction = enemyObj.direction;

                setInterval(() => {
                    const nextPosition = enemyPosition + direction * 2;
                    let collidesWithWall = false;
                    const impassableTiles = document.querySelectorAll('.wall');

                    for (let tile of impassableTiles) {
                        const tileRect = tile.getBoundingClientRect();
                        const enemyRect = enemy.getBoundingClientRect();
                        if (nextPosition < tileRect.right && nextPosition + enemyRect.width > tileRect.left &&
                            enemyRect.top < tileRect.bottom && enemyRect.bottom > tileRect.top) {
                            collidesWithWall = true;
                            break;
                        }
                    }

                    if (collidesWithWall) {
                        direction *= -1;
                        enemyObj.direction = direction;
                    } else {
                        enemyPosition = nextPosition;
                        enemy.style.left = `${enemyPosition}px`;
                    }
                }, 30);
            }

            // Start enemy movements
            enemies.forEach(enemyObj => moveEnemy(enemyObj));

            // Player movement and key interactions
            window.addEventListener('keydown', (event) => {
                let pos = mover.getBoundingClientRect();
                let newPos = { left: pos.left, top: pos.top };

                // Move based on arrow keys
                switch (event.key) {
                    case 'ArrowUp': newPos.top -= 5; break;
                    case 'ArrowDown': newPos.top += 5; break;
                    case 'ArrowLeft': newPos.left -= 5; break;
                    case 'ArrowRight': newPos.left += 5; break;
                    case 'x':
                    case 'X':
                        if (isOnKeyTile && keyTile) {
                            keyTile.style.backgroundColor = keyStates.get(keyTile) ? originalColor : 'blue';
                            keyStates.set(keyTile, !keyStates.get(keyTile));
                            activatedKeyTiles += keyStates.get(keyTile) ? 1 : -1;
                            let winTile = document.getElementById('win');
                            winTile.style.backgroundColor = [...keyStates.values()].every(Boolean) ? 'gold' : '';
                        }
                        return;
                }

                // Check for wall collision
                let collides = [...document.querySelectorAll('.wall')].some(tile => {
                    let tileRect = tile.getBoundingClientRect();
                    return newPos.left < tileRect.right && newPos.left + pos.width > tileRect.left &&
                           newPos.top < tileRect.bottom && newPos.top + pos.height > tileRect.top;
                });

                // Update position if no collision
                if (!collides) {
                    mover.style.left = newPos.left + 'px';
                    mover.style.top = newPos.top + 'px';
                }

                detectKeyTile();
            });

            // Detect if player is on a key tile
            function detectKeyTile() {
                const playerRect = mover.getBoundingClientRect();
                isOnKeyTile = false;
                keyTile = null;
                for (const [tile, active] of keyStates.entries()) {
                    const tileRect = tile.getBoundingClientRect();
                    if (playerRect.left < tileRect.right && playerRect.right > tileRect.left &&
                        playerRect.top < tileRect.bottom && playerRect.bottom > tileRect.top) {
                        isOnKeyTile = true;
                        keyTile = tile;
                        break;
                    }
                }
            }

            // Initial detection
            detectKeyTile();

            // Actualizar el puntaje y vidas según el tipo de objeto recogido
            function updateScore(imageName) {
                if (imageName === 'lata' || imageName === 'botella') {
                    score += 10;
                } else if (imageName === 'pez') {
                    life = life - 1;
                    perdre_vida();
                    checkLives();
                    console.log(life);
                }
                scoreDisplay.textContent = 'Puntos: ' + score;

            }

            // Actualizar el vidas según el tipo de objeto no recogido
            function updateLife(imageName) {
                if (imageName === 'lata' || imageName === 'botella') {
                    life = life - 1;
                    perdre_vida();
                    checkLives();
                    console.log(life);
                }

            }

            function crear_cor(num) {
                let cor = document.createElement('img');
                vides.push(cor);
                cor.className = "cor";
                cor.id = num + 1;
                cor.src = '../img/vida.png';
                cor.style.position = "absolute"; // Ensure absolute positioning

                // Add horizontal offset to position hearts
                lifeContainer.appendChild(cor);
                tableContainer.appendChild(lifeContainer);
            }

            function imprimir_vides() {
                for (let i = 0; i < 3; i++) {
                    crear_cor(i);
                }
            }


            function perdre_vida() {
                if (vides.length > 0) {
                    let vida = vides.pop();
                    let corActiu = document.getElementById(vida.id);
                    lifeContainer.removeChild(corActiu);
                }
            }

            imprimir_vides();
        }
    </script>

</body>
</html>